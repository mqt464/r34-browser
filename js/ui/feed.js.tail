
function toggleFavorite(p){
  let nowFav;
  if (favSet.has(p.id)) {
    favSet.delete(p.id);
    favorites.ids = favorites.ids.filter(id => id !== p.id);
    delete favorites.map[p.id];
    haptic(15);
    nowFav = false;
  } else {
    favSet.add(p.id);
    favorites.ids.unshift(p.id);
    favorites.map[p.id] = p;
    haptic(35);
    nowFav = true;
  }
  saveLS(LS.favorites, favorites);
  $$('.post-card').forEach(c => {
    if (c.dataset.id === p.id) $('.fav', c)?.classList.toggle('active', favSet.has(p.id));
  });
  return nowFav;
}

function renderFavorites(){
  clearFeed();
  if (!favorites.ids.length){ renderEmptyState('No favorites yet. Double-tap or click ? to add.'); return; }
  const posts = favorites.ids.map(id => favorites.map[id]).filter(Boolean);
  renderPosts(posts);
  reachedEnd = true;
}

export async function showTagsOverlay(p){
  els.tagsOverlay.hidden = false;
  const skel = Array.from({ length: 18 }, (_, i) => `<span class="skel" style="width:${40 + ((i*27)%80)}px"></span>`).join('');
  els.tagsBody.innerHTML = `<div class="tags-loading">${skel}</div>`;
  const tags = (p.tags||'').split(/\s+/).filter(Boolean);
  try{
    const N = Math.min(25, tags.length);
    const metas = await Promise.allSettled(tags.slice(0,N).map(t => API.tagMeta(t)));
    const typeMap = new Map();
    metas.forEach((res, idx) => {
      if (res.status !== 'fulfilled') return;
      const v = res.value;
      const arr = Array.isArray(v) ? v : (Array.isArray(v?.tag) ? v.tag : []);
      if (!arr.length) return;
      const nameKey = tags[idx].toLowerCase();
      const obj = arr.find(o => String(o.name||'').toLowerCase() === nameKey) || arr[0];
      const typeNum = Number(obj?.type);
      if (Number.isFinite(typeNum)) typeMap.set(tags[idx], typeNum);
    });
    const groupsMap = { 'General': [], 'Artists': [], 'Characters': [], 'Copyrights': [], 'Meta': [] };
    for (const t of tags){
      const ty = typeMap.get(t);
      if (ty === 1) groupsMap['Artists'].push(t);
      else if (ty === 4) groupsMap['Characters'].push(t);
      else if (ty === 3) groupsMap['Copyrights'].push(t);
      else if (ty === 5) groupsMap['Meta'].push(t);
      else groupsMap['General'].push(t);
    }
    const frag = document.createDocumentFragment();
    const st = getSearchState();
    for (const [name, arr] of Object.entries(groupsMap)){
      if (!arr.length) continue;
      const sec = document.createElement('div');
      sec.innerHTML = `<h4 style="margin:8px 0 6px 0">${name}</h4>`;
      const chips = document.createElement('div'); chips.className = 'chips small';
      for (const t of arr){
        const key = String(t||'').toLowerCase(); const inInc = (st.include||[]).includes(key); const inExc = (st.exclude||[]).includes(key);
        const c = document.createElement('span'); c.className = 'chip' + (inExc ? ' excluded' : (inInc ? ' in-search' : ''));
        c.innerHTML = `<span class="t">${escapeHtml(t)}</span><span class="x" title="Add">+</span>`;
        c.title = 'Add to search';
        c.addEventListener('click', () => addSearchTag(t));
        chips.appendChild(c);
      }
      try{
        const cls = name === 'Meta' ? 'tag-meta' : name === 'Characters' ? 'tag-character' : name === 'Copyrights' ? 'tag-copyright' : name === 'Artists' ? 'tag-artist' : 'tag-general';
        chips.querySelectorAll('.chip').forEach(ch => {
          ch.classList.add(cls);
          // Remove original click listener by cloning the node
          const node = ch.cloneNode(true);
          ch.parentNode.replaceChild(node, ch);
          const label = node.querySelector('.t')?.textContent || '';
          const key2 = label.toLowerCase();
          const inInc2 = (st.include||[]).includes(key2);
          const inExc2 = (st.exclude||[]).includes(key2);
          node.classList.toggle('in-search', inInc2);
          node.classList.toggle('excluded', inExc2);
          const x = node.querySelector('.x');
          if (x) x.textContent = inInc2 ? '✓' : (inExc2 ? '-' : '+');
          node.title = inInc2 ? 'In search — click to remove' : (inExc2 ? 'Excluded — click to include' : 'Add to search');
          node.addEventListener('click', () => {
            const cur = getSearchState();
            const isInc = (cur.include||[]).includes(key2);
            const isExc = (cur.exclude||[]).includes(key2);
            if (isExc) { toggleSearchTag(key2, true); }
            else if (isInc) { removeSearchTag(key2, false); }
            else { addSearchTag(label); }
            const st3 = getSearchState();
            const ni2 = (st3.include||[]).includes(key2);
            const ne2 = (st3.exclude||[]).includes(key2);
            node.classList.toggle('in-search', ni2);
            node.classList.toggle('excluded', ne2);
            const x2 = node.querySelector('.x');
            if (x2) x2.textContent = ni2 ? '✓' : (ne2 ? '-' : '+');
            node.title = ni2 ? 'In search — click to remove' : (ne2 ? 'Excluded — click to include' : 'Add to search');
          });
        });
      }catch{}
      sec.appendChild(chips);
      frag.appendChild(sec);
    }
    els.tagsBody.innerHTML = '';
    els.tagsBody.appendChild(frag);
  }catch(e){
    els.tagsBody.innerHTML = `<div class="note" style="padding:12px">${escapeHtml(p.tags||'No tags')}</div>`;
  }
}
export function hideTagsOverlay(){ els.tagsOverlay.hidden = true; }

export function onScroll(){
  const y = window.scrollY || window.pageYOffset;
  const max = Math.max(1, document.documentElement.scrollHeight - window.innerHeight);
  const pct = clamp(y / max, 0, 1);
  els.scrollProgress.style.width = (pct*100).toFixed(1) + '%';
  const dy = y - lastScrollY;
  const dir = dy > 0 ? 1 : (dy < 0 ? -1 : direction);
  // Distance thresholds to avoid instant show/hide on tiny scrolls
  const showThreshold = 1200; // only consider button after this scroll depth
  const showMinDelta = 90;    // need to scroll up at least this much to show
  const hideMinDelta = 120;   // need to scroll down at least this much to hide
  const nearTop = y < 200;
  // Accumulate deltas in current direction; reset when direction flips
  if (dy < 0) { upDelta += -dy; downDelta = 0; }
  else if (dy > 0) { downDelta += dy; upDelta = 0; }

  if (dir < 0 && y > showThreshold && upDelta >= showMinDelta) { showToTopBtn(); upDelta = 0; }
  if ((dir > 0 && downDelta >= hideMinDelta) || nearTop) { hideToTopBtn(); downDelta = 0; }
  direction = dir;
  lastScrollY = y;
}

function showToTopBtn(){
  const b = els.toTop; if (!b) return;
  if (b.classList.contains('visible')) return;
  if (b.hidden) { b.hidden = false; void b.offsetWidth; }
  b.classList.add('visible');
  // Reset deltas to avoid immediate hide on minor scrolls
  upDelta = 0; downDelta = 0;
}
function hideToTopBtn(){
  const b = els.toTop; if (!b) return;
  if (!b.classList.contains('visible')) { b.hidden = true; return; }
  b.classList.remove('visible');
  // Reset deltas to avoid immediate show on minor scrolls
  upDelta = 0; downDelta = 0;
  const onEnd = () => {
    if (!b.classList.contains('visible')) { b.hidden = true; }
    b.removeEventListener('transitionend', onEnd);
  };
  b.addEventListener('transitionend', onEnd);
}


