
      // RealBooru: derive full-res candidates from any known URL (samples or images)
      if (isRB){
        const tryDerive = (s) => {
          if (!s) return null;
          let m = /\/samples\/(..\/..\/)(?:sample_)?([a-f0-9]{32})\.(?:jpg|jpeg|png|gif|webp)/i.exec(s);
          if (!m) m = /\/images\/(..\/..\/)([a-f0-9]{32})\.(?:jpg|jpeg|png|gif|webp)/i.exec(s);
          if (!m) m = /\/thumbnails\/(..\/..\/)(?:thumbnail_)?([a-f0-9]{32})\.(?:jpg|jpeg|png|gif|webp)/i.exec(s);
          return m ? { prefix: m[1], md5: m[2] } : null;
        };
        const info = tryDerive(srcRaw) || tryDerive(deproxy(p?.file_url||'')) || tryDerive(deproxy(p?.preview_url||'')) || tryDerive(deproxy(p?.sample_url||''));
        if (info){
          const push = (u) => { if (!u) return; if (u !== src0 && !candidates.includes(u)) candidates.push(u); };
          const order = ['gif','png','jpg','jpeg','webp'];
          // Try direct originals first (gif/png/jpg/jpeg/webp)
          for (const ex of order){ push(`https://realbooru.com/images/${info.prefix}${info.md5}.${ex}`); }
          // Only if proxy toggle is on, add proxied originals as additional options
          const allowProxy = !!settings?.proxyImages && !!String(settings?.corsProxy||'').trim();
          if (allowProxy){
            const toP = (u) => proxyUrlIfNeeded(u);
            for (const ex of order){ push(toP(`https://realbooru.com/images/${info.prefix}${info.md5}.${ex}`)); }
          }
        }
      }

      // Generic fallbacks (only used after original attempts)
      // NOTE: Do NOT add preview_url (thumbnails) here; it can cause visible downgrades
      const addCand = (u) => { if (!u) return; const v = proxyUrlIfNeeded(u); if (v !== src0 && !candidates.includes(v)) candidates.push(v); };
      try{
        if (p.file_url && !['mp4','webm'].includes(String(p.file_ext||'').toLowerCase())) addCand(p.file_url);
      }catch{}

      // First pass: without referer (often helps)
      imgEl.setAttribute('referrerpolicy','no-referrer');
      let idx = 0;
      let triedWithRef = false;
      const tryNext = () => {
        if (idx >= candidates.length){
          if (!triedWithRef){
            // Second pass: allow referer
            triedWithRef = true;
            imgEl.removeAttribute('referrerpolicy');
            idx = 0;
          } else {
            // Exhausted all options: stop spinner and leave current image as-is
            try{ skel?.remove(); }catch{}
            return;
          }
        }
        const cand = candidates[idx++];
        // Preload candidate with timeout to avoid indefinite pending states
        const test = new Image();
        const rp = imgEl.getAttribute('referrerpolicy') || '';
        if (rp) try{ test.referrerPolicy = rp; }catch{}
        let done = false;
        const to = setTimeout(() => { if (done) return; done = true; tryNext(); }, 12000);
        test.onload = () => {
          if (done) return; done = true; clearTimeout(to);
          // If we just loaded a non-thumbnail original, stop any further downgrade fallback
          try{
            const isOriginal = /\/images\//i.test(cand) && !/\/thumbnail_/i.test(cand);
            if (isOriginal) { imgEl.removeEventListener('error', onErr); try{ imgEl.dataset.hi = '1'; }catch{} }
          }catch{}
          imgEl.src = cand;
        };
        test.onerror = () => { if (done) return; done = true; clearTimeout(to); tryNext(); };
        test.src = cand;
      };
      // If the element itself errors after a successful preload, advance
      const onErr = () => { if (imgEl?.dataset?.hi === '1') return; tryNext(); };
      imgEl.addEventListener('error', onErr, { passive: true });
      imgEl.addEventListener('load', () => skel?.remove(), { once: true });
      // Proactively advance for RealBooru samples or thumbnails (consider deproxied path)
      if (isRB && (srcRaw.includes('/samples/') || srcRaw.includes('/thumbnails/'))) tryNext();
    }catch{}
  }

  return art;
}

function proxyUrlIfNeeded(url){
  try{
    if (!url) return url;
    const p = String(settings?.corsProxy||'').trim();
    if (!p || !settings?.proxyImages) return url;

    if (p.includes('{url}')) return p.replace('{url}', encodeURIComponent(url));
    if (/[?&]$/.test(p)) return p + encodeURIComponent(url);
    if (/[?&]url=$/i.test(p)) return p + encodeURIComponent(url);
    const lower = p.toLowerCase();
    if (lower.includes('r.jina.ai') || /\/http\/?$/.test(lower)) return p.replace(/\/?$/,'/') + url;
    if (/^https?:\/\/[^/]+\/?$/.test(p)) return p.replace(/\/?$/,'/') + url;
    return p + url;
  }catch{ return url; }
}

// Build proxy URL ignoring the media toggle; used for last-resort fallbacks
function proxyUrlAlways(url){
  try{
    if (!url) return url;
    const p = String(settings?.corsProxy||'').trim();
    if (!p) return url;

    if (p.includes('{url}')) return p.replace('{url}', encodeURIComponent(url));
    if (/[?&]$/.test(p)) return p + encodeURIComponent(url);
    if (/[?&]url=$/i.test(p)) return p + encodeURIComponent(url);
    const lower = p.toLowerCase();
    if (lower.includes('r.jina.ai') || /\/http\/?$/.test(lower)) return p.replace(/\/?$/,'/') + url;
    if (/^https?:\/\/[^/]+\/?$/.test(p)) return p.replace(/\/?$/,'/') + url;
    return p + url;
  }catch{ return url; }
}

async function enrichRealBooruCard(art){
  const p = art?.__post; if (!p) return;
  try{
    let postUrl = '';
    if (typeof p?.source === 'string' && p.source.includes('realbooru.com')) postUrl = p.source;
    else if (p?.id) postUrl = `https://realbooru.com/index.php?page=post&s=view&id=${encodeURIComponent(p.id)}`;
    else return;
    const cacheKey = 'rb:post:' + postUrl;
    let html = sessionStorage.getItem(cacheKey);
    if (!html) {
      html = await fetchText(postUrl, /*allowProxy*/ true);
      try { sessionStorage.setItem(cacheKey, html); } catch {}
    }

    // Prefer full-resolution images first (especially GIFs), then fall back to video
    const imgUrls = [];
    const reImg = /https?:\/\/realbooru\.com\/images\/[^"'<>\s]+?\.(?:jpg|jpeg|png|gif|webp)/ig;
    let m2; while ((m2 = reImg.exec(html))){ const u = m2[0]; if (!imgUrls.includes(u)) imgUrls.push(u); }
    if (imgUrls.length){
      // Prefer non-thumbnail originals when available; else allow thumbnail_ path (RB often 302s it to original)
      const ordered = (() => {
        const nonThumb = imgUrls.filter(u => !/\/thumbnail_/i.test(u));
        return nonThumb.length ? nonThumb : imgUrls;
      })();
      // Always prefer GIF when present, then PNG/JPG/JPEG/WEBP
      const order = ['gif','png','jpg','jpeg','webp'];
      const best = order.map(ex => ordered.find(u => u.toLowerCase().endsWith('.'+ex))).find(Boolean) || ordered[0];
      const media = $('.post-media', art); if (!media) return;
      try { p.file_url = best; p.file_ext = (best.split('.').pop() || '').toLowerCase(); } catch {}
      let img = $('img', media);
      if (img){
        // If we already have a non-thumbnail original shown, keep it
        try{
          const cur = img.currentSrc || img.getAttribute('src') || '';
          const curRaw = cur;
          if (/realbooru\.com/i.test(curRaw) && curRaw.includes('/images/') && !/thumbnail_/i.test(curRaw)) {
            return; // don't downgrade an already-upgraded image
          }
        }catch{}

        // Replace node to remove any existing error handlers from the initial fallback chain
        try{
          const clone = img.cloneNode(true);
          img.replaceWith(clone);
          img = clone;
        }catch{}

        img.referrerPolicy = 'no-referrer';
        img.decoding = 'async';
        img.loading = 'lazy';

        // Derive md5/prefix to try canonical originals even if best is a thumbnail link
        const derive = (s) => {
          try{
            if (!s) return null;
            let m = /\/images\/(..\/..\/)(?:thumbnail_)?([a-f0-9]{32})\.(?:jpg|jpeg|png|gif|webp)/i.exec(s);
            if (!m) m = /\/samples\/(..\/..\/)(?:sample_)?([a-f0-9]{32})\.(?:jpg|jpeg|png|gif|webp)/i.exec(s);
            if (!m) m = /\/thumbnails\/(..\/..\/)(?:thumbnail_)?([a-f0-9]{32})\.(?:jpg|jpeg|png|gif|webp)/i.exec(s);
            return m ? { prefix: m[1], md5: m[2] } : null;
          }catch{ return null; }
        };
        const info = derive(best) || derive(imgUrls[0]) || null;
        const directCandidates = [];
        if (info){
          for (const ex of order){ directCandidates.push(`https://realbooru.com/images/${info.prefix}${info.md5}.${ex}`); }
          // Also include thumbnail_ variant as a late fallback (server may 302 to original)
          directCandidates.push(`https://realbooru.com/images/${info.prefix}thumbnail_${info.md5}.jpg`);
        }
        // Ensure we also consider the discovered best URL as a fallback
        if (!directCandidates.includes(best)) directCandidates.push(best);

        // One-shot proxy fallback will be applied only after direct attempts
        let idx = 0;
        let proxiedUsed = false;
        const next = () => {
          if (idx >= directCandidates.length){
            if (!proxiedUsed){
              proxiedUsed = true;
              // Try proxied version of the first candidate (or best) as a final fallback
              const base = directCandidates[0] || best;
              img.onerror = null;
              img.src = proxyUrlIfNeeded(base);
              return;
            }
            return;
          }
          const cand = directCandidates[idx++];
          // Try direct first; on error advance to next
          img.onerror = next;
          img.src = cand;
        };
        img.addEventListener('load', () => {
          try{
            const u = img.currentSrc || img.getAttribute('src') || '';
            const isOriginal = /\/images\//i.test(u) && !/\/thumbnail_/i.test(u);
            if (isOriginal) { try{ img.dataset.hi = '1'; }catch{}; img.onerror = null; }
            const sk = $('.media-skel', media); sk && sk.remove();
          }catch{}
        }, { once: false });
        next();
      }
      return;
    }

    // If no full-res image found, check for video URLs and prefer those
    const vidUrls = [];
    const reVid = /https?:\/\/realbooru\.com\/(?:images|videos)\/[^"'<>\s]+?\.(?:mp4|webm)/ig;
    let m; while ((m = reVid.exec(html))){ const u = m[0]; if (!vidUrls.includes(u)) vidUrls.push(u); }
    if (vidUrls.length){
      vidUrls.sort((a,b)=> (b.endsWith('.mp4')?0:1) - (a.endsWith('.mp4')?0:1));
      const direct = vidUrls[0];
      const proxied = proxyUrlIfNeeded(direct);
      p.video_candidates = vidUrls.slice(0,4);
      p.file_ext = (direct.split('.').pop()||'').toLowerCase();
      p.file_url = direct;
      const media = $('.post-media', art); if (!media) return;
      const img = $('img', media);
      let video = $('video', media);
      if (!video){
        video = document.createElement('video');
        video.preload = 'metadata'; video.playsInline = true; video.muted = true; video.controls = true;
        video.poster = p.preview_url || p.sample_url || '';
        try { video.removeAttribute('crossorigin'); video.setAttribute('referrerpolicy','no-referrer'); } catch {}
        video.src = direct; // direct first
        video.onerror = () => { video.onerror = null; video.src = proxied; };
        if (img) img.replaceWith(video); else media.appendChild(video);
        video.addEventListener('click', () => { if (video.paused) video.play().catch(()=>{}); else video.pause(); });
        const vis = new IntersectionObserver(entries => { entries.forEach(e => { if (!e.isIntersecting) video.pause(); }); }, { rootMargin: '200px' });
        vis.observe(video);
      } else {
        video.src = direct;
        video.onerror = () => { video.onerror = null; video.src = proxied; };
      }
      return;
    }
  }catch{}
}
